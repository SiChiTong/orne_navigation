#!/usr/bin/env python
# vim:fileencoding=utf-8

import rospy
from geometry_msgs.msg import *
from std_msgs.msg import *
import tf
import math
from std_srvs.srv import Trigger
from fulanghua_srvs.srv import Pose
from espeak import espeak

class GoalManager:
    def __init__(self, nav_publisher, world_frame, robot_frame):
        self.nav_publisher = nav_publisher
        self.tf_listener = tf.TransformListener()

        self.world_frame = world_frame
        self.robot_frame = robot_frame

    def set_goal(self, goal_pose):
        self.goal_pose = goal_pose

    def get_goal(self):
        return self.goal_pose

    def start_nav(self):
        self.nav_publisher.publish(self.goal_pose)

    def is_arrive_goal(self,dist_thr=1.0):
        try:
            (trans, rot) = self.tf_listener.lookupTransform(self.world_frame, self.robot_frame, rospy.Time(0))
            x = trans[0]
            y = trans[1]

            dist = math.sqrt(math.pow(x - self.goal_pose.pose.position.x, 2) + math.pow(y - self.goal_pose.pose.position.y, 2))

        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
            return False

        if dist < dist_thr:
            return True
        else:
            return False

class TsukubaChallengeStrategy:
    def __init__(self):
        rospy.init_node('tsukuba_challenge_strategy')
        self.start_nav_server = rospy.Service('start_nav', Trigger, self.start_nav_callback)
        self.resume_nav_server = rospy.Service('resume_nav', Trigger, self.resume_nav_callback)

        rospy.Subscriber('/target_position', PointStamped, self.target_position_cb, queue_size=10)
        rospy.Subscriber('/move_base_simple/goal', PoseStamped, self.goal_cb, queue_size=10)

        self.goal_pose_pub = rospy.Publisher('/move_base_simple/goal', PoseStamped, queue_size=10)

        suspend_pose_cfg = rospy.get_param('~suspend_pose')
        resume_pose_cfg = rospy.get_param('~resume_pose')
        self.world_frame = rospy.get_param('~world_frame', 'map')
        self.robot_frame = rospy.get_param('~robot_frame', 'base_link')
        self.is_search = rospy.get_param('~is_search', False)
        self.search_rect = rospy.get_param('~search_rect',[[0,0],[0,0]])

        self.suspend_pose = geometry_msgs.msg.Pose()
        self.suspend_pose.position.x = suspend_pose_cfg['position']['x']
        self.suspend_pose.position.y = suspend_pose_cfg['position']['y']
        self.suspend_pose.position.z = suspend_pose_cfg['position']['z']
        self.suspend_pose.orientation.x = suspend_pose_cfg['orientation']['x']
        self.suspend_pose.orientation.y = suspend_pose_cfg['orientation']['y']
        self.suspend_pose.orientation.z = suspend_pose_cfg['orientation']['z']
        self.suspend_pose.orientation.w = suspend_pose_cfg['orientation']['w']

        self.resume_pose = geometry_msgs.msg.Pose()
        self.resume_pose.position.x = resume_pose_cfg['position']['x']
        self.resume_pose.position.y = resume_pose_cfg['position']['y']
        self.resume_pose.position.z = resume_pose_cfg['position']['z']
        self.resume_pose.orientation.x = resume_pose_cfg['orientation']['x']
        self.resume_pose.orientation.y = resume_pose_cfg['orientation']['y']
        self.resume_pose.orientation.z = resume_pose_cfg['orientation']['z']
        self.resume_pose.orientation.w = resume_pose_cfg['orientation']['w']

        print "suspend_pose = " + str(self.suspend_pose)
        print "resume_pose = " + str(self.resume_pose)

        self.tf_listener = tf.TransformListener()
        self.goal_manager = GoalManager(self.goal_pose_pub, self.world_frame, self.robot_frame)

    def target_position_cb(self, data):
        if self.is_in_area() and not self.aproach_flag:
            self.target_position = data
            self.aproach_flag = True

    def goal_cb(self, data):
        self.now_goal = data

    def start_nav_callback(self, req):
        try:
            rospy.loginfo("strategy: start_nav_callback")
            rospy.wait_for_service('start_wp_nav')
            start_wp_nav = rospy.ServiceProxy('start_wp_nav', Trigger)
            return start_wp_nav()
            #rospy.loginfo(start_wp_nav())
            #return (True, "successful")
        except rospy.ServiceException, e:
            print "error: %s" % e

    def resume_nav_callback(self, req):
        try:
            rospy.loginfo('strategy: resume_nav_callback')
            rospy.wait_for_service('resume_wp_pose')
            resume_wp_nav = rospy.ServiceProxy('resume_wp_pose', Pose)
            return resume_wp_nav(self.resume_pose)
        except rospy.ServiceException, e:
            print "error: %s" % e

    def get_now_pose(self):
        ident = PoseStamped(
            header=Header(
                stamp=rospy.Time(0),
                frame_id='base_link'
            ),
            pose=geometry_msgs.msg.Pose()
        )
        robot_pose = PoseStamped()
        try:
            robot_pose = self.tf_listener.transformPose(self.world_frame, ident)
        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
            rospy.loginfo('tf except')
        return robot_pose

    def is_in_search_area(self):
        now_pose = self.get_now_pose()
        x = now_pose.pose.position.x
        y = now_pose.pose.position.y

        if x > self.search_rect[0][0] and y > self.search_rect[0][1] and x < self.search_rect[1][0] and y < self.search_rect[1][1]:
            self.is_in_area = True
        else:
            self.is_in_area = False

    def get_distance(self, pose1, pose2):
        x1 = pose1.pose.position.x
        y1 = pose1.pose.position.y
        x2 = pose2.pose.position.x
        y2 = pose2.pose.position.y
        return math.sqrt(math.pow(x1 - x2, 2) + math.pow(y1 - y2, 2))

    def init_search_target(self):
        state = not_state
        self.is_last_wp = False
        self.wp_list = []
        self.aproach_flag = False

    def spin(self):
        rate = rospy.Rate(10)
        already_send_suspend_pose = False
        state = 'not_search'
        while not rospy.is_shutdown():
            rate.sleep()

            if state == 'not_search':
                if self.is_search and self.is_in_search_area():
                    state = 'search'

            elif state == 'search':
                if self.aproach_flag:
                    state = 'search_near_point'

            elif state == 'search_near_point':
                if self.is_last_wp:
                    state = 'reverse_near_point'
                #ウェイポイントがリストに登録されていない場合は今のwpを登録する
                if not self.wp_list or self.now_goal is not self.wp_list[-1][0]:
                    self.wp_list.append([now_goal,0])
                    distance_now_wp = self.get_distance(self.wp_list[-1][0], self.target_position)
                    distance_before_wp = self.get_distance(self.wp_list[-2][0], self.target_position)
                    if distance_now_wp > distance_before_wp:
                        self.is_last_wp = True
                # ウェイポイントが登録されている場合
                else:
                    # nearポイントが登録されていない場合
                    if self.wp_list[-1][1] is 0:
                        self.wp_list[-1][1] = self.get_now_pose()
                    else:
                        distance_now = self.get_distance(self.get_now_pose(), self.target_position)
                        distance_min = self.get_distance(self.wp_list[-1][1],self.target_position)

                        if distance_now < distance_min:
                            self.wp_list[-1][1] = self.get_now_pose()

            elif state == 'reverse_near_point':
                self.wp_list.reverse()
                state = 'back_trace_wp'

            elif state == 'back_trace_wp':
                most_near_point = self.wp_list[-1][1]
                for i,wp in enumerate(self.wp_list):
                    most_near_distance = self.get_distance(most_near_point, self.target_position)
                    wp_near_distance = self.get_distance(wp[1], self.target_position)
                    if wp_near < most_near_distance:
                        most_near_point = i
                back_trace_wp = []
                for j in range(most_near_point):
                    back_trace_wp.append(self.wp_list[j][0])
                back_trace_wp.append(self.wp_list[j][1])
                wp = back_trace_wp.pop()
                rospy.wait_for_service('resume_wp_pose')
                resume_wp_nav = rospy.ServiceProxy('resume_wp_pose', Pose)
                self.goal_manager.set_goal(wp)
                self.gpal_manager.start_nav()
                state = 'aproach_near_point'

            elif state == 'aproach_near_point':
                if not len(back_trace_wp) :
                    if self.goal_manager.is_arrive_goal():
                        wp = back_trace_wp.pop()
                        self.goal_manager.set_goal(wp)
                        self.goal_manager.start_nav()
                else:
                    state = 'wait_near_point'

            elif state == 'wait_near_point':
                if self.goal_manager.is_arrive_goal():
                    state = 'aproach_target_point'

            elif state == 'aproach_target_point':
                self.goal_manager.set_goal(target_position)
                self.goal_manager.start_nav()
                state = 'wait_target_point'

            elif state == 'wait_target_point':
                if self.goal_manager.is_arrive_goal(dist_thr=3.0):
                    state = 'stop_target_nav'

            elif state == 'stop_target_nav':
                self.goal_manager.set_goal(self.get_now_pose)
                self.goal_manager.start_nav()
                state = 'wait_stop_nav'

            elif state == 'wait_stop_nav':
                if self.goal_manager.is_arrive_goal():
                    espeak.synth('I found a subject')
                    state = 'restart_waypoints_nav'

            elif state == 'restart_waypoints_nav':
                self.init_search_target()
                rospy.wait_for_service('start_wp_nav')
                start_wp_nav = rospy.ServiceProxy('start_wp_nav', Trigger)

            try:
                (trans, rot) = self.tf_listener.lookupTransform(self.world_frame, self.robot_frame, rospy.Time(0))
                x = trans[0]
                y = trans[1]

                dist = math.sqrt(math.pow(x - self.suspend_pose.position.x, 2) + math.pow(y - self.suspend_pose.position.y, 2))

                print "robot_gl = ("  + str(x) + ", " + str(y) + ")"
                print "dist = " + str(dist)

                if(dist < 1.0) and not already_send_suspend_pose:
                    rospy.loginfo('strategy: send suspending request')
                    rospy.wait_for_service('suspend_wp_pose')
                    suspend_wp_nav = rospy.ServiceProxy('suspend_wp_pose', Pose)
                    print "suspend_wp_nav() = " + str(suspend_wp_nav(self.suspend_pose))
                    already_send_suspend_pose = True

            except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
                continue

if __name__ == '__main__':
    strategy = TsukubaChallengeStrategy()
    strategy.spin()
